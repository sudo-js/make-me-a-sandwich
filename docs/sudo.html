<!DOCTYPE html>

<html>
<head>
  <title>sudo.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>sudo.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../util/util'</span>);
<span class="hljs-keyword">var</span> delegates = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../mixins/delegates'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>##Base Class Object</p>
<p>All sudo.js objects inherit base, giving the ability
to utilize delegation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>{
  constructor() {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>can delegate</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.delegates = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>a beautiful and unique snowflake</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.uid = _.unique();</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>should be overridden in child classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.role = <span class="hljs-string">'base'</span>;
  }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>add the actual methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>_.mixin(Base.prototype, delegates);

<span class="hljs-built_in">module</span>.exports = Base;

<span class="hljs-keyword">var</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter;
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../util/util'</span>);
<span class="hljs-keyword">var</span> delegates = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../mixins/delegates'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>##Emitter Class Object</p>
<p>A Base Class extending the core Node module EventEmitter and our delegation functionality</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Emitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>{
  constructor() {
    <span class="hljs-keyword">super</span>();</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>can delegate</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.delegates = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>a beautiful and unique snowflake</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.uid = _.unique();</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>should be overridden in child classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.role = <span class="hljs-string">'base'</span>;
  }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>add the actual methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>_.mixin(Emitter.prototype, delegates);

<span class="hljs-built_in">module</span>.exports = Emitter;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>##Delegates mixin
Used by the two base classes, Base and Emitter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">module</span>.exports = {</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>###addDelegate
Push an instance of a Class Object into this object’s <code>_delegates_</code> list.</p>
<p><code>param</code> {Object} <code>del</code>. An instance of a sudo.delegates Class Object
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  addDelegate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">del</span>) </span>{
    del.delegator = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.delegates.push(del);
    <span class="hljs-keyword">if</span>(<span class="hljs-string">'addedAsDelegate'</span> <span class="hljs-keyword">in</span> del) del.addedAsDelegate(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>###delegate
From this object’s list of delegates find the object whose <code>_role_</code> matches
the passed <code>name</code> and:</p>
<ol>
<li>if <code>meth</code> is falsy return the delegate.
2 if <code>meth</code> is truthy bind its method (to the delegate) and return the method</li>
</ol>
<p><code>param</code> {String} <code>role</code> The role property to match in this object’s delegates list
<code>param</code> {String} <code>meth</code> Optional method to bind to the action this delegate is being used for
<code>returns</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  delegate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">role, meth</span>) </span>{
    <span class="hljs-keyword">let</span> del = <span class="hljs-keyword">this</span>.delegates, i;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; del.length; i++) {
      <span class="hljs-keyword">if</span>(del[i].role === role) {
        <span class="hljs-keyword">if</span>(!meth) <span class="hljs-keyword">return</span> del[i];
        <span class="hljs-keyword">return</span> del[i][meth].bind(del[i]);
      }
    }
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>###getDelegate
Fetch a delegate whose role property matches the passed in argument.
Uses the <code>delegate</code> method in its ‘single argument’ form, included for
API consistency</p>
<p><code>param</code> {String} <code>role</code>
‘returns’ {Object|undefined}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  getDelegate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">role</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.delegate(role); },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>###removeDelegate
From this objects <code>delegates</code> list remove the object (there should only ever be 1)
whose role matches the passed in argument</p>
<p><code>param</code> {String} <code>role</code>
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  removeDelegate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">role</span>) </span>{
    <span class="hljs-keyword">let</span> del = <span class="hljs-keyword">this</span>.delegates, i;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; del.length; i++) {
      <span class="hljs-keyword">if</span>(del[i].role === role) {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>no <em>delegator</em> for you</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        del[i].delegator = <span class="hljs-literal">undefined</span>;
        del.splice(i, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
};

<span class="hljs-keyword">var</span> Base = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../base/base'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>##Container</p>
<p>A container is any object that can both contain other objects and
itself be contained.</p>
<p><code>param</code> {Array|Object} ‘arg’. Optional array or hash
of child objects which the Container will add as child objects
via <code>addChildren</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>{
  constructor(arg) {
    <span class="hljs-keyword">super</span>();

    <span class="hljs-keyword">this</span>.role = <span class="hljs-string">'container'</span>;
    <span class="hljs-keyword">this</span>.children = [];
    <span class="hljs-keyword">this</span>.childNames = {};

    <span class="hljs-keyword">if</span>(arg) <span class="hljs-keyword">this</span>.addChildren(arg);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>###addChild
Adds a Class instance to this container’s list of children.
Also adds an ‘index’ property and an entry in the childNames hash.
If <code>addedToParent</code> is found on the child, call it, sending <code>this</code> as an argument.</p>
<p><code>param</code> {Object} <code>c</code>. Other Class instance.
<code>param</code> {String} <code>name</code>. An optional name for the child that will go in the childNames hash.
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  addChild(c, name) {
    <span class="hljs-keyword">var</span> ch = <span class="hljs-keyword">this</span>.children;
    c.parent = <span class="hljs-keyword">this</span>;
    c.index = ch.length;
    <span class="hljs-keyword">if</span>(name) {
      c.name = name;
      <span class="hljs-keyword">this</span>.childNames[name] = c.index;
    }
    ch.push(c);
    <span class="hljs-keyword">if</span>(<span class="hljs-string">'addedToParent'</span> <span class="hljs-keyword">in</span> c) c.addedToParent(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>###addChildren
Allows for multiple children to be added to this Container by passing
either an Array or an Object literal.</p>
<p>see <code>addChild</code></p>
<p><code>param</code> {Array|Object} <code>arg</code>. An array of children to add or an
Object literal in the form {name: child}
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  addChildren(arg) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>normalize the arg</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">let</span> _keys = <span class="hljs-built_in">Array</span>.isArray(arg) ? <span class="hljs-literal">undefined</span> : <span class="hljs-built_in">Object</span>.keys(arg);
    <span class="hljs-keyword">let</span> ary = _keys || arg;

    ary.forEach(c =&gt; { _keys ? <span class="hljs-keyword">this</span>.addChild(arg[c], c) : <span class="hljs-keyword">this</span>.addChild(c); });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>###bubble
By default, <code>bubble</code> returns the current view’s parent (if it has one)</p>
<p><code>returns</code> {Object|undefined}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  bubble() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent; }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>###eachChild
Call a named method and pass any args to each child in a container’s
collection of children</p>
<p><code>param</code> {*} Any number of arguments the first of which must be
The named method to look for and call. Other args are passed through
<code>returns</code> {object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  eachChild(...args) {
    <span class="hljs-keyword">let</span> meth = args.shift();
    <span class="hljs-keyword">this</span>.children.forEach(c =&gt; { <span class="hljs-keyword">if</span>(meth <span class="hljs-keyword">in</span> c) c[meth].apply(c, args); });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>###getChild
If a child was added with a name, via <code>addChild</code>,
that object can be fetched by name. This prevents us from having to reference a
containers children by index. That is possible however, though not preferred.</p>
<p><code>param</code> {String|Number} <code>id</code>. The string <code>name</code> or numeric <code>index</code> of the child to fetch.
<code>returns</code> {Object|undefined} The found child</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  getChild(id) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> id === <span class="hljs-string">'string'</span> ? <span class="hljs-keyword">this</span>.children[<span class="hljs-keyword">this</span>.childNames[id]] :
      <span class="hljs-keyword">this</span>.children[id];
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>###<em>indexChildren</em>
Method is called with the <code>index</code> property of a subview that is being removed.
Beginning at <code>i</code> decrement subview indices.
<code>param</code> {Number} <code>i</code>
<code>private</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _indexChildren_(i) {
    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">this</span>.children;
    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">this</span>.childNames;
    <span class="hljs-keyword">let</span> len;
    <span class="hljs-keyword">for</span> (len = c.length; i &lt; len; i++) {
      c[i].index--;</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>adjust any entries in childNames</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span>(c[i].name <span class="hljs-keyword">in</span> obj) obj[c[i].name] = c[i].index;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>###removeChild
Find the intended child from my list of children and remove it, removing the name reference and re-indexing
remaining children. This method does not remove the child’s DOM.
Override this method, doing whatever you want to the child’s DOM, then call <code>base(&#39;removeChild&#39;)</code> to do so.</p>
<p>If the child being removed has a <code>removedFromParent</code> method it will be called after the parenth has
finished, passing itself(the parent) as an argument.</p>
<p><code>param</code> {String|Number|Object} <code>arg</code>. Children will always have an <code>index</code> number, and optionally a <code>name</code>.
If passed a string <code>name</code> is assumed, so be sure to pass an actual number if expecting to use index.
An object will be assumed to be an actual sudo Class Object.
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  removeChild(arg) {
    <span class="hljs-keyword">let</span> i;
    <span class="hljs-keyword">let</span> t = <span class="hljs-keyword">typeof</span> arg;
    <span class="hljs-keyword">let</span> c;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>normalize the input</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(t === <span class="hljs-string">'object'</span>) c = arg;
    <span class="hljs-keyword">else</span> c = t === <span class="hljs-string">'string'</span> ? <span class="hljs-keyword">this</span>.children[<span class="hljs-keyword">this</span>.childNames[arg]] : <span class="hljs-keyword">this</span>.children[arg];</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>if no child exists based on the argument, don’t try to remove it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(!c) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    i = c.index;</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>remove from the children Array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.children.splice(i, <span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>remove from the named child hash if present</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.childNames[c.name];</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>child is now an <code>orphan</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">delete</span> c.parent;
    <span class="hljs-keyword">delete</span> c.index;
    <span class="hljs-keyword">delete</span> c.name;
    <span class="hljs-keyword">this</span>._indexChildren_(i);
    <span class="hljs-keyword">if</span>(<span class="hljs-string">'removedFromParent'</span> <span class="hljs-keyword">in</span> c) c.removedFromParent(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>###removeChildren
Remove all children.</p>
<p>see <code>removeChild</code>
<code>returns</code> {object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  removeChildren() {
    <span class="hljs-keyword">let</span> n = <span class="hljs-keyword">this</span>.children.length;
    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.removeChild(<span class="hljs-keyword">this</span>.children[n - <span class="hljs-number">1</span>]);
      n--;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>###send
The call to the specific method on a (un)specified target happens here.
If this Object is part of a <code>sudo.Container</code> maintained hierarchy
the ‘target’ may be left out, causing the <code>bubble()</code> method to be called.
What this does is allow children of a <code>sudo.Container</code> to simply pass
events  upward, delegating the responsibility of deciding what to do to the parent.</p>
<p>NOTE Only the first target method found is called, bubbling stops there.
If you wish it to continue call <code>send</code> again…</p>
<p><code>param</code> {*} Any number of arguments is supported, but the first is the only one searched for info.
A sendMethod will be located by:</p>
<ol>
<li>using the first argument if it is a string</li>
<li>looking for a <code>sendMethod</code> property if it is an object
Any args will be passed to the sendMethod
<code>returns</code> {Object} <code>this</code></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>  send(...args) {
    <span class="hljs-keyword">let</span> d = <span class="hljs-keyword">this</span>.data;
    <span class="hljs-keyword">let</span> meth;
    <span class="hljs-keyword">let</span> targ;
    <span class="hljs-keyword">let</span> fn;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>.sendMethod useful for direct event binding to a send</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(d &amp;&amp; <span class="hljs-string">'sendMethod'</span> <span class="hljs-keyword">in</span> d) meth = d.sendMethod;</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>this.send(‘foo’, …args)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> args[<span class="hljs-number">0</span>] === <span class="hljs-string">'string'</span>) meth = args.shift();</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>if there was no send target specified bail out</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!meth) <span class="hljs-keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>target is either specified or my parent</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    targ = d &amp;&amp; d.sendTarget || <span class="hljs-keyword">this</span>.bubble();</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>obvious chance for errors here, don’t be dumb</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fn = targ[meth];
    <span class="hljs-keyword">while</span>(!fn &amp;&amp; (targ = targ.bubble())) fn = targ[meth];
    <span class="hljs-keyword">if</span>(fn) fn.apply(targ, args);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = Container;

<span class="hljs-keyword">var</span> Emitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../base/emitter'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../util/util'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>##Store</p>
<p>Store Objects expose methods for setting and getting key:val pairs on this
object’s internal <code>data</code> hash. Notice there are no <code>get</code> or <code>set</code> operations
as for simple “one level deep” operations you should simply:</p>
<pre><code><span class="hljs-keyword">this</span>.data.foo = <span class="hljs-string">'bar'</span>;
<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.data.foo;
</code></pre><p>The methods provided here are either for <em>path</em> based operations or give the
ability to (un)set / get multiple vals at once.</p>
<p>Being a subclass of Emitterbase, EventEmitter methods are available. After
processing, a store may emit the <code>change</code> event signifying it is ready to be queried</p>
<p><code>param</code> {object} data. An initial state for this store.</p>
<p><code>constructor</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Emitter</span> </span>{
  constructor(data) {
    <span class="hljs-keyword">super</span>();

    <span class="hljs-keyword">this</span>.role = <span class="hljs-string">'store'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>stores operate on the inner data hash…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.data = data || {};
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>###getPath
Uses the <code>getpath</code> function operating on the store’s data hash.</p>
<p><code>param</code> {string} <code>path</code>
<code>returns</code> {*|undefined}. The value at keypath or undefined if not found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  getPath(path) {
    <span class="hljs-keyword">return</span> _.getPath(path, <span class="hljs-keyword">this</span>.data);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>###gets
Assembles and returns an object of key:value pairs for each key
contained in the passed in Array.</p>
<p><code>param</code> {array} <code>ary</code>. An array of keys.
<code>returns</code> {object}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  gets(ary) {
    <span class="hljs-keyword">let</span> obj = {};
    ary.forEach(str =&gt; {
      obj[str] = !~str.indexOf(<span class="hljs-string">'.'</span>) ? <span class="hljs-keyword">this</span>.data[str] : <span class="hljs-keyword">this</span>.getPath(str);
    });
    <span class="hljs-keyword">return</span> obj;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>###handleDispatch
A noop by default, override in you subclass to perform the necessary
computation on the recieved dispatch payload.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  handleDispatch() {}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>###register
Register a callback with the dispatcher, assigning the returned
“dispatch token” as <code>this.dispatchId</code>.</p>
<p><code>param</code> {Object} <code>dispatcher</code>. The dispatcher instance to register with
<code>param</code> {String|Function} Optional argument indicating the function to
register with. If falsy, <code>handleDispatch</code> is assumed. If a String, the
method is bound to this instance when registered. If a Function, it is
simply passed as-is</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  register(dispatcher, fn = <span class="hljs-string">'handleDispatch'</span>) {
    <span class="hljs-keyword">let</span> cb = <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">'string'</span> ? <span class="hljs-keyword">this</span>[fn].bind(<span class="hljs-keyword">this</span>) : fn;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>if there is no cb to register, indicate with an falsy ID</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.dispatchId = cb ? dispatcher.register(cb) : <span class="hljs-literal">null</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>###setPath
Uses the <code>setpath</code> function operating on the model’s
data hash.</p>
<p><code>param</code> {String} <code>path</code>
<code>param</code> {*} <code>v</code>
<code>returns</code> {Object} this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  setPath(path, v) {
    _.setPath(path, v, <span class="hljs-keyword">this</span>.data);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>###sets
Invokes <code>set()</code> or <code>setPath()</code> for each key value pair in <code>obj</code>.
Any listeners for those keys or paths will be called.</p>
<p><code>param</code> {Object} <code>obj</code>. The keys and values to set.
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  sets(obj) {
    <span class="hljs-built_in">Object</span>.keys(obj).forEach(k =&gt; {
      !~k.indexOf(<span class="hljs-string">'.'</span>) ? (<span class="hljs-keyword">this</span>.data[k] = obj[k]) : <span class="hljs-keyword">this</span>.setPath(k, obj[k]);
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>###unsetPath
Uses the <code>unsetPath</code> method, operating on this models data hash</p>
<p><code>param</code> {String} path
<code>returns</code> {Object} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unsetPath(path) {
    _.unsetPath(path, <span class="hljs-keyword">this</span>.data);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>###unsets
Deletes a number of keys or paths from this object’s data store</p>
<p><code>param</code> {array} <code>ary</code>. An array of keys or paths.
<code>returns</code> {Objaect} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unsets(ary) {
    ary.forEach(k =&gt; { !~k.indexOf(<span class="hljs-string">'.'</span>) ? (<span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.data[k]) : <span class="hljs-keyword">this</span>.unsetPath(k); });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = Store;

<span class="hljs-keyword">var</span> Container = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../container/container'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>##View
Given a template identifier, <code>data.template</code>, use that for content
Given a shadow host, <code>data.shadowHost</code>, create shadow root there
Given a template import <code>data.import</code>, fetch my template from there</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Container</span> </span>{
  constructor(data) {
    <span class="hljs-keyword">super</span>();

    <span class="hljs-keyword">this</span>.role = <span class="hljs-string">'view'</span>;
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.state = {};
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>###addedToParent
All view components will setup their shadow DOM when added to a container.
This does mean that we expect any view component to be housed in a container,
whether another view or the top level <code>Dispatcher</code>. Steps for setup are:</p>
<ul>
<li>Locate my template, either in the main document or import it</li>
<li>Locate my Shadow Host, save a ref <code>this.host</code></li>
<li>Create my Shadow Root at the Shadow Host, saved at <code>this.root</code></li>
<li>Clone the template and insert it at the Shadow Root</li>
</ul>
<p>There is a path for a simple, non-templated, non Shadow Dom element. Simply
provide a selector via <code>el</code> and it will become the <code>host</code>. Since the state
hydration for temlated (and non) is the same this will work</p>
<p><code>arg</code> {object} <code>parent</code>. The Container instance adding this object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  addedToParent() {
    <span class="hljs-keyword">let</span> tmplHost, tmpl;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>if my .template is a string identifier, locate it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.data.template === <span class="hljs-string">'string'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>locate the template host, can be in the main doc or an import</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.data.import) {
        tmplHost = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-keyword">this</span>.data.import).import;
      } <span class="hljs-keyword">else</span> tmplHost = <span class="hljs-built_in">document</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>now the actual template</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      tmpl = tmplHost &amp;&amp; tmplHost.querySelector(<span class="hljs-keyword">this</span>.data.template);
    } <span class="hljs-comment">// else tmpl = this.data.template; -- do we want to support passing it in?</span>
    <span class="hljs-keyword">let</span> tmplContent = tmpl &amp;&amp; <span class="hljs-built_in">document</span>.importNode(tmpl.content, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>the eventual location, assumed to be in the main doc</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.host = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-keyword">this</span>.data.shadowHost || <span class="hljs-keyword">this</span>.data.el);
    <span class="hljs-keyword">if</span> (tmplContent &amp;&amp; <span class="hljs-keyword">this</span>.host &amp;&amp; (<span class="hljs-string">'createShadowRoot'</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.host)) {
      <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">this</span>.host.createShadowRoot();</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>place the template content into the host</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.root &amp;&amp; <span class="hljs-keyword">this</span>.root.appendChild(tmplContent);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>###mergeState</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  mergeState(state) {
    <span class="hljs-built_in">Object</span>.keys(state).forEach(key =&gt; {
      <span class="hljs-keyword">this</span>.state[key] = state[key];
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.render(<span class="hljs-keyword">this</span>.state);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>###render
The insertion of the template at the Shadow Host, in <code>addedToParent</code>,
sets up our desired “presentation” details with any initial data that may have
been present. Calls to render should be the product of changing state in your
application, view components reacting to stores emitting change events.
As such, a <code>state</code> object is expected that can be inspected. If keys in the
said hash match attributes of elements in this object’s Shadow Host ELement,
the values located at those keys will be inserted there. For example,
given this markup in the shadow host:
   <div id="#fooHost">
     <h3></h3>
     <span class="foo"></span>
   </div></p>
<p>Then passed this <code>state</code> object:
   { ‘.foo’: ‘Bar’, h3: ‘Foo’ }</p>
<p>Will result in:
   <div id="#fooHost">
     <h3>Foo</h3>
     <span class="foo">Bar</span>
   </div></p>
<p>You can, obviously, override this to provide different behavior</p>
<p>The actual presentation details, of course, are abstracted away in the
Shadow Dom, via your template. NOTE: We do expect that you have processed the
values to be inserted down to a simple <code>textContent</code> by this point</p>
<p><code>param</code> {Object} <code>state</code>. A hash of key:val pairs that map to this component’s markup.
<code>param</code> {Bool} <code>reset</code>. Optional flag to remove any previous state, using the
passed-in state object as the new baseline.
<code>returns</code> {oject} <code>this</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  render(state = <span class="hljs-keyword">this</span>.state) {</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>host is mandatory</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.host) <span class="hljs-keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>TODO diff based on a <em>prevState</em> ??</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.keys(state).forEach(key =&gt; {
      <span class="hljs-keyword">this</span>.host.querySelector(key).textContent = <span class="hljs-keyword">this</span>.state[key];
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>###resetState
Given a hash of key:val pairs set any that are present and empty any previous
keys in my state object.
Essentially this ‘blanks out’ any previous keys that were present, but are
not present in the passed-in object, by setting their value to an empty string.
<code>mergeState</code> is then called with the passed-in object.</p>
<p><code>param</code> {Object} <code>state</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  resetState(state) {</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>empty the value of any keys not in the passed-in state object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.state).forEach(key =&gt; {
      <span class="hljs-keyword">if</span>(!(key <span class="hljs-keyword">in</span> state)) <span class="hljs-keyword">this</span>.state[key] = <span class="hljs-string">''</span>;
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>now that any prev entries are erased (but kept) the new state can be merged</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mergeState(state);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>###update
Default implementation is a noop. An overridden method may exist on your
subclass to map the data passed in to one suitable for passing to render.
This is the preferred method for parents to call with dispatch data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  update() {}
}

<span class="hljs-built_in">module</span>.exports = View;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
